diff -Nrup a/ibss.c b/ibss.c
--- a/ibss.c	2011-02-04 13:29:39.000000000 +0100
+++ b/ibss.c	2011-05-03 21:31:00.000000000 +0200
@@ -27,6 +27,7 @@ static int join_ibss(struct nl80211_stat
 	char *value = NULL, *sptr = NULL;
 	float rate;
 	int bintval;
+	unsigned int htval;
 
 	if (argc < 2)
 		return 1;
@@ -44,6 +45,12 @@ static int join_ibss(struct nl80211_stat
 	argv++;
 	argc--;
 
+	if (argc && parse_channel_typ.e(argv[0], &htval)) {
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, htval);
+		argv++;
+		argc--;
+	}
+
 	if (argc && strcmp(argv[0], "fixed-freq") == 0) {
 		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
 		argv++;
@@ -134,7 +141,7 @@ COMMAND(ibss, leave, NULL,
 	NL80211_CMD_LEAVE_IBSS, 0, CIB_NETDEV, leave_ibss,
 	"Leave the current IBSS cell.");
 COMMAND(ibss, join,
-	"<SSID> <freq in MHz> [fixed-freq] [<fixed bssid>] [beacon-interval <TU>]"
+	"<SSID> <freq in MHz> [HT20|HT40+|HT40-] [fixed-freq] [<fixed bssid>] [beacon-interval <TU>]"
 	" [basic-rates <rate in Mbps,rate2,...>] [mcast-rate <rate in Mbps>] "
 	"[key d:0:abcde]",
 	NL80211_CMD_JOIN_IBSS, 0, CIB_NETDEV, join_ibss,
diff -Nrup a/iw.h b/iw.h
--- a/iw.h	2011-02-04 13:29:39.000000000 +0100
+++ b/iw.h	2011-05-03 14:52:02.000000000 +0200
@@ -130,6 +130,7 @@ void mac_addr_n2a(char *mac_addr, unsign
 unsigned char *parse_hex(char *hex, size_t *outlen);
 
 int parse_keys(struct nl_msg *msg, char **argv, int argc);
+int parse_channel_type(const char *str, unsigned int *htval);
 
 void print_ht_mcs(const __u8 *mcs);
 void print_ampdu_length(__u8 exponent);
diff -Nrup a/phy.c b/phy.c
--- a/phy.c	2011-02-04 13:29:39.000000000 +0100
+++ b/phy.c	2011-05-03 14:52:02.000000000 +0200
@@ -33,30 +33,14 @@ static int handle_freqchan(struct nl_msg
 			   int argc, char **argv)
 {
 	char *end;
-	static const struct {
-		const char *name;
-		unsigned int val;
-	} htmap[] = {
-		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
-		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
-		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
-	};
 	unsigned int htval = NL80211_CHAN_NO_HT;
 	unsigned int freq;
-	int i;
 
 	if (!argc || argc > 2)
 		return 1;
 
-	if (argc == 2) {
-		for (i = 0; i < ARRAY_SIZE(htmap); i++) {
-			if (strcasecmp(htmap[i].name, argv[1]) == 0) {
-				htval = htmap[i].val;
-				break;
-			}
-		}
-		if (htval == NL80211_CHAN_NO_HT)
-			return 1;
+	if (argc == 2 && !parse_channel_type(argv[1], &htval)) {
+		return 1;
 	}
 
 	if (!*argv[0])
diff -Nrup a/phy.c.orig b/phy.c.orig
--- a/phy.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/phy.c.orig	2011-02-04 13:29:39.000000000 +0100
@@ -0,0 +1,348 @@
+#include <stdbool.h>
+#include <errno.h>
+#include <net/if.h>
+#include <strings.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int handle_name(struct nl80211_state *state,
+		       struct nl_cb *cb,
+		       struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	if (argc != 1)
+		return 1;
+
+	NLA_PUT_STRING(msg, NL80211_ATTR_WIPHY_NAME, *argv);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, name, "<new name>", NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_name,
+	"Rename this wireless device.");
+
+static int handle_freqchan(struct nl_msg *msg, bool chan,
+			   int argc, char **argv)
+{
+	char *end;
+	static const struct {
+		const char *name;
+		unsigned int val;
+	} htmap[] = {
+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
+	};
+	unsigned int htval = NL80211_CHAN_NO_HT;
+	unsigned int freq;
+	int i;
+
+	if (!argc || argc > 2)
+		return 1;
+
+	if (argc == 2) {
+		for (i = 0; i < ARRAY_SIZE(htmap); i++) {
+			if (strcasecmp(htmap[i].name, argv[1]) == 0) {
+				htval = htmap[i].val;
+				break;
+			}
+		}
+		if (htval == NL80211_CHAN_NO_HT)
+			return 1;
+	}
+
+	if (!*argv[0])
+		return 1;
+	freq = strtoul(argv[0], &end, 10);
+	if (*end)
+		return 1;
+
+	if (chan)
+		freq = ieee80211_channel_to_frequency(freq);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, htval);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+
+static int handle_freq(struct nl80211_state *state,
+		       struct nl_cb *cb, struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	return handle_freqchan(msg, false, argc, argv);
+}
+COMMAND(set, freq, "<freq> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_freq,
+	"Set frequency/channel the hardware is using, including HT\n"
+	"configuration.");
+COMMAND(set, freq, "<freq> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_freq, NULL);
+
+static int handle_chan(struct nl80211_state *state,
+		       struct nl_cb *cb, struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	return handle_freqchan(msg, true, argc, argv);
+}
+COMMAND(set, channel, "<channel> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_chan, NULL);
+COMMAND(set, channel, "<channel> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_chan, NULL);
+
+static int handle_fragmentation(struct nl80211_state *state,
+				struct nl_cb *cb, struct nl_msg *msg,
+				int argc, char **argv)
+{
+	unsigned int frag;
+
+	if (argc != 1)
+		return 1;
+
+	if (strcmp("off", argv[0]) == 0)
+		frag = -1;
+	else {
+		char *end;
+
+		if (!*argv[0])
+			return 1;
+		frag = strtoul(argv[0], &end, 10);
+		if (*end != '\0')
+			return 1;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD, frag);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, frag, "<fragmentation threshold|off>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_fragmentation,
+	"Set fragmentation threshold.");
+
+static int handle_rts(struct nl80211_state *state,
+		      struct nl_cb *cb, struct nl_msg *msg,
+		      int argc, char **argv)
+{
+	unsigned int rts;
+
+	if (argc != 1)
+		return 1;
+
+	if (strcmp("off", argv[0]) == 0)
+		rts = -1;
+	else {
+		char *end;
+
+		if (!*argv[0])
+			return 1;
+		rts = strtoul(argv[0], &end, 10);
+		if (*end != '\0')
+			return 1;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD, rts);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, rts, "<rts threshold|off>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_rts,
+	"Set rts threshold.");
+
+static int handle_netns(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_PID,
+		    strtoul(argv[0], &end, 10)); 
+
+	if (*end != '\0')
+		return 1;
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, netns, "<pid>",
+	NL80211_CMD_SET_WIPHY_NETNS, 0, CIB_PHY, handle_netns,
+	"Put this wireless device into a different network namespace");
+
+static int handle_coverage(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+	unsigned int coverage;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+	coverage = strtoul(argv[0], &end, 10);
+	if (coverage > 255)
+		return 1;
+
+	if (*end)
+		return 1;
+
+	NLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS, coverage);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, coverage, "<coverage class>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_coverage,
+	"Set coverage class (1 for every 3 usec of air propagation time).\n"
+	"Valid values: 0 - 255.");
+
+static int handle_distance(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+	unsigned int distance, coverage;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+
+	distance = strtoul(argv[0], &end, 10);
+
+	if (*end)
+		return 1;
+
+	/*
+	 * Divide double the distance by the speed of light in m/usec (300) to
+	 * get round-trip time in microseconds and then divide the result by
+	 * three to get coverage class as specified in IEEE 802.11-2007 table
+	 * 7-27. Values are rounded upwards.
+	 */
+	coverage = (distance + 449) / 450;
+	if (coverage > 255)
+		return 1;
+
+	NLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS, coverage);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, distance, "<distance>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_distance,
+	"Set appropriate coverage class for given link distance in meters.\n"
+	"Valid values: 0 - 114750");
+
+static int handle_txpower(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	enum nl80211_tx_power_setting type;
+	int mbm;
+
+	/* get the required args */
+	if (argc != 1 && argc != 2)
+		return 1;
+
+	if (!strcmp(argv[0], "auto"))
+		type = NL80211_TX_POWER_AUTOMATIC;
+	else if (!strcmp(argv[0], "fixed"))
+		type = NL80211_TX_POWER_FIXED;
+	else if (!strcmp(argv[0], "limit"))
+		type = NL80211_TX_POWER_LIMITED;
+	else {
+		printf("Invalid parameter: %s\n", argv[0]);
+		return 2;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_TX_POWER_SETTING, type);
+
+	if (type != NL80211_TX_POWER_AUTOMATIC) {
+		if (argc != 2) {
+			printf("Missing TX power level argument.\n");
+			return 2;
+		}
+
+		mbm = atoi(argv[1]);
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL, mbm);
+	} else if (argc != 1)
+		return 1;
+
+	return 0;
+
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, txpower, "<auto|fixed|limit> [<tx power in mBm>]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_txpower,
+	"Specify transmit power level and setting type.");
+COMMAND(set, txpower, "<auto|fixed|limit> [<tx power in mBm>]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_txpower,
+	"Specify transmit power level and setting type.");
+
+static int handle_antenna(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	char *end;
+	uint32_t tx_ant = 0, rx_ant = 0;
+
+	if (argc == 1 && strcmp(argv[0], "all") == 0) {
+		tx_ant = 0xffffffff;
+		rx_ant = 0xffffffff;
+	} else if (argc == 1) {
+		tx_ant = rx_ant = strtoul(argv[0], &end, 0);
+		if (*end)
+			return 1;
+	}
+	else if (argc == 2) {
+		tx_ant = strtoul(argv[0], &end, 0);
+		if (*end)
+			return 1;
+		rx_ant = strtoul(argv[1], &end, 0);
+		if (*end)
+			return 1;
+	} else
+		return 1;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_TX, tx_ant);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_RX, rx_ant);
+
+	return 0;
+
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, antenna, "<bitmap> | all | <tx bitmap> <rx bitmap>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_antenna,
+	"Set a bitmap of allowed antennas to use for TX and RX.\n"
+	"The driver may reject antenna configurations it cannot support.");
diff -Nrup a/util.c b/util.c
--- a/util.c	2011-02-04 13:29:39.000000000 +0100
+++ b/util.c	2011-05-03 14:52:02.000000000 +0200
@@ -345,6 +345,33 @@ int parse_keys(struct nl_msg *msg, char
 	return 2;
 }
 
+/*
+ * Convert a string "HT20", "HT40+" or "HT40-" into nl80211
+ * value. Conversion is case insensitive. Returns 1 on success, 0 on error.
+ */
+
+int parse_channel_type(const char *str, unsigned int *htval)
+{
+	static const struct {
+		const char *name;
+		unsigned int val;
+	} htmap[] = {
+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(htmap); i++) {
+		if (strcasecmp(htmap[i].name, str) == 0) {
+			*htval = htmap[i].val;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
 static void print_mcs_index(const __u8 *mcs)
 {
 	unsigned int mcs_bit, prev_bit = -2, prev_cont = 0;

